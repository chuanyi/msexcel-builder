// Generated by CoffeeScript 1.11.1

/*
  MS Excel 2007 Creameater v0.0.1
  Author : chuanyi.zheng@gmail.com
  Extended: pieter@protobi.com
  History: 2012/11/07 first created
 */

(function() {
  var Anchor, CalcChain, ContentTypes, DocPropsApp, Image, ImageType, JSDateToExcel, JSZip, SharedStrings, Sheet, Style, Workbook, WorksheetComments, WorksheetCommentsDrawings, XlDrawingRels, XlWorkbook, XlWorkbookRels, XlWorksheetRels, addressRegex, baseXl, colCache, excelbuilder, fs, tool, xml,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if ((typeof window !== "undefined" && window !== null) && (window.JSZip != null)) {
    JSZip = window.JSZip;
  } else if (typeof require !== 'undefined') {
    JSZip = require('jszip');
  } else {
    throw "JSZip not defined";
  }

  if ((typeof window !== "undefined" && window !== null) && (window.xmlbuilder != null)) {
    xml = window.xmlbuilder;
  } else if (typeof require !== 'undefined') {
    xml = require('xmlbuilder');
  } else {
    throw "xmlbuilder not defined";
  }

  if ((typeof window !== "undefined" && window !== null) && (window.xmlbuilder != null)) {
    fs = window.xmlbuilder;
  } else if (typeof require !== 'undefined') {
    fs = require('fs');
  }

  tool = {
    i2a: function(column) {
      var letter, temp;
      temp = void 0;
      letter = '';
      while (column > 0) {
        temp = (column - 1) % 26;
        letter = String.fromCharCode(temp + 65) + letter;
        column = (column - temp - 1) / 26;
      }
      return letter;
    },
    cell: function(col, row) {
      return this.i2a(col) + row;
    }
  };

  ImageType = {
    SVG: "image/svg+xml",
    PNG: "image/png"
  };

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  addressRegex = /^[A-Z]+\d+$/;

  colCache = {
    _dictionary: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
    _l2nFill: 0,
    _l2n: {},
    _n2l: [],
    _level: function(n) {
      if (n <= 26) {
        return 1;
      }
      if (n <= 26 * 26) {
        return 2;
      }
      return 3;
    },
    _fill: function(level) {
      var c, l1, l2, l3, n, v;
      c = void 0;
      v = void 0;
      l1 = void 0;
      l2 = void 0;
      l3 = void 0;
      n = 1;
      if (level >= 4) {
        throw new Error('Out of bounds. Excel supports columns from 1 to 16384');
      }
      if (this._l2nFill < 1 && level >= 1) {
        while (n <= 26) {
          c = this._dictionary[n - 1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 1;
      }
      if (this._l2nFill < 2 && level >= 2) {
        n = 27;
        while (n <= 26 + 26 * 26) {
          v = n - (26 + 1);
          l1 = v % 26;
          l2 = Math.floor(v / 26);
          c = this._dictionary[l2] + this._dictionary[l1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 2;
      }
      if (this._l2nFill < 3 && level >= 3) {
        n = 26 + 26 * 26 + 1;
        while (n <= 16384) {
          v = n - (26 * 26 + 26 + 1);
          l1 = v % 26;
          l2 = Math.floor(v / 26) % 26;
          l3 = Math.floor(v / (26 * 26));
          c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 3;
      }
    },
    l2n: function(l) {
      if (!this._l2n[l]) {
        this._fill(l.length);
      }
      if (!this._l2n[l]) {
        throw new Error('Out of bounds. Invalid column letter: ' + l);
      }
      return this._l2n[l];
    },
    n2l: function(n) {
      if (n < 1 || n > 16384) {
        throw new Error(n + ' is out of bounds. Excel supports columns from 1 to 16384');
      }
      if (!this._n2l[n]) {
        this._fill(this._level(n));
      }
      return this._n2l[n];
    },
    _hash: {},
    validateAddress: function(value) {
      if (!addressRegex.test(value)) {
        throw new Error('Invalid Address: ' + value);
      }
      return true;
    },
    decodeAddress: function(value) {
      var addr, address, char, col, colNumber, hasCol, hasRow, i, row, rowNumber;
      addr = value.length < 5 && this._hash[value];
      if (addr) {
        return addr;
      }
      hasCol = false;
      col = '';
      colNumber = 0;
      hasRow = false;
      row = '';
      rowNumber = 0;
      i = 0;
      char = void 0;
      while (i < value.length) {
        char = value.charCodeAt(i);
        if (!hasRow && char >= 65 && char <= 90) {
          hasCol = true;
          col += value[i];
          colNumber = colNumber * 26 + char - 64;
        } else if (char >= 48 && char <= 57) {
          hasRow = true;
          row += value[i];
          rowNumber = rowNumber * 10 + char - 48;
        } else if (hasRow && hasCol && char !== 36) {
          break;
        }
        i++;
      }
      if (!hasCol) {
        colNumber = void 0;
      } else if (colNumber > 16384) {
        throw new Error('Out of bounds. Invalid column letter: ' + col);
      }
      if (!hasRow) {
        rowNumber = void 0;
      }
      value = col + row;
      address = {
        address: value,
        col: colNumber,
        row: rowNumber,
        $col$row: '$' + col + '$' + row
      };
      if (colNumber <= 100 && rowNumber <= 100) {
        this._hash[value] = address;
        this._hash[address.$col$row] = address;
      }
      return address;
    },
    getAddress: function(r, c) {
      var address;
      if (c) {
        address = this.n2l(c) + r;
        return this.decodeAddress(address);
      }
      return this.decodeAddress(r);
    },
    decode: function(value) {
      var br, parts, result, tl;
      parts = value.split(':');
      if (parts.length === 2) {
        tl = this.decodeAddress(parts[0]);
        br = this.decodeAddress(parts[1]);
        result = {
          top: Math.min(tl.row, br.row),
          left: Math.min(tl.col, br.col),
          bottom: Math.max(tl.row, br.row),
          right: Math.max(tl.col, br.col)
        };
        result.tl = this.n2l(result.left) + result.top;
        result.br = this.n2l(result.right) + result.bottom;
        result.dimensions = result.tl + ':' + result.br;
        return result;
      }
      return this.decodeAddress(value);
    },
    decodeEx: function(value) {
      var address, bottom, br, groups, left, parts, reference, right, sheetName, tl, top;
      groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
      sheetName = groups[1] || groups[2];
      reference = groups[3];
      parts = reference.split(':');
      if (parts.length > 1) {
        tl = this.decodeAddress(parts[0]);
        br = this.decodeAddress(parts[1]);
        top = Math.min(tl.row, br.row);
        left = Math.min(tl.col, br.col);
        bottom = Math.max(tl.row, br.row);
        right = Math.max(tl.col, br.col);
        tl = this.n2l(left) + top;
        br = this.n2l(right) + bottom;
        return {
          top: top,
          left: left,
          bottom: bottom,
          right: right,
          sheetName: sheetName,
          tl: {
            address: tl,
            col: left,
            row: top,
            $col$row: '$' + this.n2l(left) + '$' + top,
            sheetName: sheetName
          },
          br: {
            address: br,
            col: right,
            row: bottom,
            $col$row: '$' + this.n2l(right) + '$' + bottom,
            sheetName: sheetName
          },
          dimensions: tl + ':' + br
        };
      }
      if (reference.startsWith('#')) {
        if (sheetName) {
          return {
            sheetName: sheetName,
            error: reference
          };
        } else {
          return {
            error: reference
          };
        }
      }
      address = this.decodeAddress(reference);
      if (sheetName) {
        return {
          sheetName: sheetName,
          address: address.address,
          col: address.col,
          row: address.row,
          $col$row: '$' + col + '$' + row
        };
      } else {
        return address;
      }
    },
    encodeAddress: function(row, col) {
      return colCache.n2l(col) + row;
    },
    encode: function() {
      switch (arguments.length) {
        case 2:
          return colCache.encodeAddress(arguments[0], arguments[1]);
        case 4:
          return colCache.encodeAddress(arguments[0], arguments[1]) + ':' + colCache.encodeAddress(arguments[2], arguments[3]);
        default:
          throw new Error('Can only encode with 2 or 4 arguments');
      }
    },
    inRange: function(range, address) {
      var bottom, col, left, right, row, top;
      left = range[0];
      top = range[1];
      right = range[range.length - 2];
      bottom = range[range.length - 1];
      col = address[0];
      row = address[1];
      return col >= left && col <= right && row >= top && row <= bottom;
    }
  };

  ContentTypes = (function() {
    function ContentTypes(book) {
      this.book = book;
    }

    ContentTypes.prototype._getKnowImageTypes = function() {
      var image, imagesToAdd, imagesToAddDistinct, len, len1, p, q, ref, ref1, sheet;
      imagesToAdd = [];
      debugger;
      imagesToAddDistinct = {};
      ref = this.book.sheets;
      for (p = 0, len = ref.length; p < len; p++) {
        sheet = ref[p];
        ref1 = sheet.images;
        for (q = 0, len1 = ref1.length; q < len1; q++) {
          image = ref1[q];
          if (!!imagesToAddDistinct[image.extension]) {
            imagesToAdd.push({
              Extension: image.extension,
              ContentType: image.contentType
            });
          }
        }
      }
      return imagesToAdd;
    };

    ContentTypes.prototype.toxml = function() {
      var i, image, len, len1, p, q, ref, ref1, ref2, sheet, t, types;
      types = xml.create('Types', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      types.att('xmlns', 'http://schemas.openxmlformats.org/package/2006/content-types');
      types.ele('Default', {
        Extension: 'png',
        ContentType: 'image/png'
      });
      types.ele('Default', {
        Extension: 'svg',
        ContentType: 'image/svg+xml'
      });
      types.ele('Default', {
        Extension: 'rels',
        ContentType: 'application/vnd.openxmlformats-package.relationships+xml'
      });
      types.ele('Default', {
        Extension: 'xml',
        ContentType: 'application/xml'
      });
      types.ele('Default', {
        Extension: 'vml',
        ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing'
      });
      types.ele('Override', {
        PartName: '/xl/workbook.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'
      });
      for (i = p = 1, ref = this.book.sheets.length; 1 <= ref ? p <= ref : p >= ref; i = 1 <= ref ? ++p : --p) {
        types.ele('Override', {
          PartName: '/xl/worksheets/sheet' + i + '.xml',
          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'
        });
        types.ele('Override', {
          PartName: '/xl/comments' + i + '.xml',
          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml'
        });
      }
      types.ele('Override', {
        PartName: '/xl/theme/theme1.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml'
      });
      types.ele('Override', {
        PartName: '/xl/calcChain.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml'
      });
      types.ele('Override', {
        PartName: '/xl/styles.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'
      });
      ref1 = this.book.sheets;
      for (q = 0, len = ref1.length; q < len; q++) {
        sheet = ref1[q];
        ref2 = sheet.images;
        for (t = 0, len1 = ref2.length; t < len1; t++) {
          image = ref2[t];
          types.ele('Override', {
            PartName: '/xl/drawings/drawing' + image.id + '.xml',
            ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml'
          });
        }
      }
      types.ele('Override', {
        PartName: '/docProps/core.xml',
        ContentType: 'application/vnd.openxmlformats-package.core-properties+xml'
      });
      types.ele('Override', {
        PartName: '/docProps/app.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.extended-properties+xml'
      });
      types.ele('Override', {
        PartName: '/xl/sharedStrings.xml',
        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'
      });
      return types.end({
        pretty: false
      });
    };

    return ContentTypes;

  })();

  DocPropsApp = (function() {
    function DocPropsApp(book) {
      this.book = book;
    }

    DocPropsApp.prototype.toxml = function() {
      var i, p, props, ref, tmp;
      props = xml.create('Properties', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      props.att('xmlns', 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties');
      props.att('xmlns:vt', 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes');
      props.ele('Application', 'Microsoft Excel');
      props.ele('DocSecurity', '0');
      props.ele('ScaleCrop', 'false');
      tmp = props.ele('HeadingPairs').ele('vt:vector', {
        size: 2,
        baseType: 'variant'
      });
      tmp.ele('vt:variant').ele('vt:lpstr', 'Worksheets');
      tmp.ele('vt:variant').ele('vt:i4', '' + this.book.sheets.length);
      tmp = props.ele('TitlesOfParts').ele('vt:vector', {
        size: this.book.sheets.length,
        baseType: 'lpstr'
      });
      for (i = p = 1, ref = this.book.sheets.length; 1 <= ref ? p <= ref : p >= ref; i = 1 <= ref ? ++p : --p) {
        tmp.ele('vt:lpstr', this.book.sheets[i - 1].name);
      }
      props.ele('Company');
      props.ele('LinksUpToDate', 'false');
      props.ele('SharedDoc', 'false');
      props.ele('HyperlinksChanged', 'false');
      props.ele('AppVersion', '12.0000');
      return props.end({
        pretty: false
      });
    };

    return DocPropsApp;

  })();

  XlWorkbook = (function() {
    function XlWorkbook(book) {
      this.book = book;
    }

    XlWorkbook.prototype.toxml = function() {
      var definedNames, i, p, ref, tmp, wb;
      wb = xml.create('workbook', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      wb.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      wb.att('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
      wb.att('xmlns:mc', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
      wb.att('mc:Ignorable', "x15 xr xr6 xr10 xr2");
      wb.att('xmlns:x15', "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main");
      wb.att('xmlns:xr', "http://schemas.microsoft.com/office/spreadsheetml/2014/revision");
      wb.att('xmlns:xr6', "http://schemas.microsoft.com/office/spreadsheetml/2016/revision6");
      wb.att('xmlns:xr10', "http://schemas.microsoft.com/office/spreadsheetml/2016/revision10");
      wb.att('xmlns:xr2', "http://schemas.microsoft.com/office/spreadsheetml/2015/revision2");
      wb.ele('fileVersion', {
        appName: 'xl',
        lastEdited: '4',
        lowestEdited: '4',
        rupBuild: '4505'
      });
      wb.ele('workbookPr', {
        filterPrivacy: '1',
        defaultThemeVersion: '124226'
      });
      wb.ele('bookViews').ele('workbookView', {
        xWindow: '0',
        yWindow: '90',
        windowWidth: '19200',
        windowHeight: '11640'
      });
      tmp = wb.ele('sheets');
      for (i = p = 1, ref = this.book.sheets.length; 1 <= ref ? p <= ref : p >= ref; i = 1 <= ref ? ++p : --p) {
        tmp.ele('sheet', {
          name: this.book.sheets[i - 1].name,
          sheetId: '' + i,
          'r:id': 'rId' + i
        });
      }
      definedNames = wb.ele('definedNames');
      this.book.sheets.forEach(function(sheet, idx) {
        var range;
        if (sheet.autofilter) {
          definedNames.ele('definedName', {
            name: '_xlnm._FilterDatabase',
            hidden: '1',
            localSheetId: idx
          }).raw("'" + sheet.name + "'!" + sheet.getRange());
        }
        if (sheet._repeatRows || sheet._repeatCols) {
          range = '';
          if (sheet._repeatCols) {
            range += "'" + sheet.name + "'!$" + tool.i2a(sheet._repeatCols.start) + ":$" + tool.i2a(sheet._repeatCols.end);
          }
          if (sheet._repeatRows) {
            range += ",'" + sheet.name + "'!$" + sheet._repeatRows.start + ":$" + sheet._repeatRows.end;
          }
          return definedNames.ele('definedName', {
            name: "_xlnm.Print_Titles",
            localSheetId: idx
          }).raw(range);
        }
      });
      wb.ele('calcPr', {
        calcId: '124519'
      });
      return wb.end({
        pretty: false
      });
    };

    return XlWorkbook;

  })();

  XlWorkbookRels = (function() {
    function XlWorkbookRels(book) {
      this.book = book;
    }

    XlWorkbookRels.prototype.toxml = function() {
      var i, p, ref, rs;
      rs = xml.create('Relationships', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      rs.att('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
      for (i = p = 1, ref = this.book.sheets.length; 1 <= ref ? p <= ref : p >= ref; i = 1 <= ref ? ++p : --p) {
        rs.ele('Relationship', {
          Id: 'rId' + i,
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
          Target: 'worksheets/sheet' + i + '.xml'
        });
      }
      rs.ele('Relationship', {
        Id: 'rId' + (this.book.sheets.length + 1),
        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
        Target: 'theme/theme1.xml'
      });
      rs.ele('Relationship', {
        Id: 'rId' + (this.book.sheets.length + 2),
        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
        Target: 'styles.xml'
      });
      rs.ele('Relationship', {
        Id: 'rId' + (this.book.sheets.length + 3),
        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
        Target: 'sharedStrings.xml'
      });
      rs.ele('Relationship', {
        Id: 'rId' + (this.book.sheets.length + 4),
        Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',
        Target: 'calcChain.xml'
      });
      return rs.end();
      if (Object.getOwnPropertyNames(this.book.cc.cache).length > 0) {
        rs.ele('Relationship', {
          Id: 'rId' + (this.book.sheets.length + 4),
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',
          Target: 'calcChain.xml'
        });
      }
      return rs.end({
        pretty: false
      });
    };

    return XlWorkbookRels;

  })();

  XlWorksheetRels = (function() {
    function XlWorksheetRels(wsRels) {
      this.wsRels = wsRels;
    }

    XlWorksheetRels.prototype.generate = function() {};

    XlWorksheetRels.prototype.toxml = function() {
      var len, p, ref, rs, wsRel;
      rs = xml.create('Relationships', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      rs.att('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
      ref = this.wsRels;
      for (p = 0, len = ref.length; p < len; p++) {
        wsRel = ref[p];
        rs.ele('Relationship', {
          Id: wsRel.id,
          Type: wsRel.type,
          Target: wsRel.target
        });
      }
      return rs.end({
        pretty: false
      });
    };

    return XlWorksheetRels;

  })();

  WorksheetComments = (function() {
    function WorksheetComments(comments) {
      this.comments = comments;
    }

    WorksheetComments.prototype.generate = function() {};

    WorksheetComments.prototype.toxml = function() {
      var cellRef, col, comment, commentList, entry, i, len, n, note, nstr, p, props, rPr, ref, row, rs, run, text;
      rs = xml.create('comments', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      rs.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      rs.att('xmlns:mc', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
      rs.att('mc:Ignorable', 'xr');
      rs.att('xmlns:xr', 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision');
      rs.ele('authors').ele('author', 'Author');
      commentList = rs.ele('commentList');
      ref = this.comments;
      for (col in ref) {
        entry = ref[col];
        for (row in entry) {
          note = entry[row];
          cellRef = tool.cell(col, row);
          comment = commentList.ele('comment').att('ref', cellRef).att('authorId', '0').att('shapeId', '0');
          text = comment.ele('text');
          if (note && !Array.isArray(note)) {
            note = [note];
          }
          for (i = p = 0, len = note.length; p < len; i = ++p) {
            n = note[i];
            nstr = n && typeof n === 'string' ? n : n.text;
            props = n && typeof n === 'string' ? null : n.props;
            run = text.ele('r');
            rPr = run.ele('rPr');
            if (props) {
              if (props.bold) {
                rPr.ele('b');
              }
              if (props.fontSize) {
                rPr.ele('sz').att('va', props.fontSize);
              }
              if (props.fontFamily) {
                rPr.ele('rFont').att('va', props.fontFamily);
              }
            }
            run.ele('t', nstr + '\n').att('xml:space', 'preserve');
          }
        }
      }
      return rs.end({
        pretty: false
      });
    };

    return WorksheetComments;

  })();

  WorksheetCommentsDrawings = (function() {
    function WorksheetCommentsDrawings(notes) {
      this.notes = notes;
    }

    WorksheetCommentsDrawings.prototype.generate = function() {};

    WorksheetCommentsDrawings.prototype.toxml = function() {
      var anchors, cd, cellRef, col, entry, note, num_cols, num_lines, num_rows, padding, ref, row, rs, shape;
      rs = xml.create('xml');
      rs.att('xmlns:v', "urn:schemas-microsoft-com:vml");
      rs.att('xlmns:o', "urn:schemas-microsoft-com:office:office");
      rs.att('xmlns:x', "urn:schemas-microsoft-com:office:excel");
      rs.ele('o:shapelayout').att('v:ext', 'edit').ele('o:idmap').att('v:ext', 'edit').att('data', '2');
      rs.ele('v:shapetype');
      ref = this.notes;
      for (col in ref) {
        entry = ref[col];
        for (row in entry) {
          note = entry[row];
          cellRef = tool.cell(col, row);
          padding = 5;
          num_rows = 5;
          num_cols = 5;
          if (Array.isArray(note)) {
            num_lines = note.length + 1;
          }
          anchors = [+col, padding, +row - 1, padding, +col + num_cols, padding, +row + num_rows + 1, padding];
          shape = rs.ele('v:shape', {
            "id": cellRef,
            "type": "#_x0000_t202",
            "style": 'visibility:hidden',
            "fillcolor": "#EEEEEE [80]",
            "strokecolor": "#3399CC",
            "o:insetmode": "auto"
          });
          shape.ele('v:fill').att("color2", "#EEEEEE [80]");
          shape.ele('v:shadow').att("color", "none").att("obscured", "t");
          shape.ele('v:path').att('o:connecttype', 'none');
          shape.ele("v:textbox").att("style", "mso-direction-alt:auto").ele("div").att('style', 'text-align: left');
          cd = shape.ele('x:ClientData').att('ObjectType', 'Note');
          cd.ele('x:MoveWithCells');
          cd.ele('x:SizeWithCells');
          cd.ele('x:Anchor', '\n' + anchors.join(',') + '\n');
          cd.ele('x:AutoFill', 'False');
          cd.ele('x:Row', row - 1);
          cd.ele('x:Column', col - 1);
        }
      }
      return rs.end({
        pretty: false
      });
    };

    return WorksheetCommentsDrawings;

  })();

  XlDrawingRels = (function() {
    function XlDrawingRels(dwRels1) {
      this.dwRels = dwRels1;
    }

    XlDrawingRels.prototype.generate = function() {};

    XlDrawingRels.prototype.toxml = function() {
      var dwRel, len, p, ref, rs;
      rs = xml.create('Relationships', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      rs.att('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
      ref = this.dwRels;
      for (p = 0, len = ref.length; p < len; p++) {
        dwRel = ref[p];
        rs.ele('Relationship', {
          Id: dwRel.id,
          Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
          Target: dwRel.target
        });
      }
      return rs.end({
        pretty: false
      });
    };

    return XlDrawingRels;

  })();

  SharedStrings = (function() {
    function SharedStrings() {
      this.cache = {};
      this.arr = [];
    }

    SharedStrings.prototype.str2id = function(s) {
      var id;
      id = this.cache[s];
      if (id) {
        return id;
      } else {
        this.arr.push(s);
        this.cache[s] = this.arr.length;
        return this.arr.length;
      }
    };

    SharedStrings.prototype.toxml = function() {
      var i, p, ref, si, sst;
      sst = xml.create('sst', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      sst.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      sst.att('count', '' + this.arr.length);
      sst.att('uniqueCount', '' + this.arr.length);
      for (i = p = 0, ref = this.arr.length; 0 <= ref ? p < ref : p > ref; i = 0 <= ref ? ++p : --p) {
        si = sst.ele('si');
        si.ele('t', this.arr[i]);
        si.ele('phoneticPr', {
          fontId: 1,
          type: 'noConversion'
        });
      }
      return sst.end({
        pretty: false
      });
    };

    return SharedStrings;

  })();

  Anchor = (function() {
    var asInstance;

    function Anchor(worksheet, address, offset) {
      var decoded;
      this.worksheet = worksheet;
      if (offset === void 0) {
        offset = 0;
      }
      if (!address) {
        this.nativeCol = 0;
        this.nativeColOff = 0;
        this.nativeRow = 0;
        this.nativeRowOff = 0;
      } else if (typeof address === 'string') {
        decoded = colCache.decodeAddress(address);
        this.nativeCol = decoded.col + offset;
        this.nativeColOff = 0;
        this.nativeRow = decoded.row + offset;
        this.nativeRowOff = 0;
      } else if (address.nativeCol !== void 0) {
        this.nativeCol = address.nativeCol || 0;
        this.nativeColOff = address.nativeColOff || 0;
        this.nativeRow = address.nativeRow || 0;
        this.nativeRowOff = address.nativeRowOff || 0;
      } else if (address.col !== void 0) {
        this.col = address.col + offset;
        this.row = address.row + offset;
      } else {
        this.nativeCol = 0;
        this.nativeColOff = 0;
        this.nativeRow = 0;
        this.nativeRowOff = 0;
      }
      return;
    }

    Anchor.property('col', {
      get: function() {
        return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
      },
      set: function(v) {
        this.nativeCol = Math.floor(v);
        this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
      },
      enumerable: true,
      configurable: true
    });

    Anchor.property('row', {
      get: function() {
        return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
      },
      set: function(v) {
        this.nativeRow = Math.floor(v);
        this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
      },
      enumerable: true,
      configurable: true
    });

    Anchor.property('colWidth', {
      get: function() {
        if (this.worksheet && this.worksheet.width(this.nativeCol, this.nativeCol + 1)) {

        }
      },
      enumerable: true,
      configurable: true
    });

    Anchor.property('rowHeight', {
      get: function() {
        if (this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height) {
          return Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 10000);
        } else {
          return 180000;
        }
      },
      enumerable: true,
      configurable: true
    });

    Anchor.property('model', {
      get: function() {
        return {
          nativeCol: this.nativeCol,
          nativeColOff: this.nativeColOff,
          nativeRow: this.nativeRow,
          nativeRowOff: this.nativeRowOff
        };
      },
      set: function(value) {
        this.nativeCol = value.nativeCol;
        this.nativeColOff = value.nativeColOff;
        this.nativeRow = value.nativeRow;
        this.nativeRowOff = value.nativeRowOff;
      },
      enumerable: true,
      configurable: true
    });

    asInstance = function(model) {
      if (model instanceof Anchor || model === null) {
        return model;
      } else {
        return new Anchor(model);
      }
    };

    Anchor.prototype.toxml = function(xml) {
      var wb;
      wb = xml.create('workbook', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      wb.ele('from').ele('workbookView', {
        xWindow: '0',
        yWindow: '90',
        windowWidth: '19200',
        windowHeight: '11640'
      });
      wb.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      wb.att('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
      wb.ele('fileVersion', {
        appName: 'xl',
        lastEdited: '4',
        lowestEdited: '4',
        rupBuild: '4505'
      });
      wb.ele('workbookPr', {
        filterPrivacy: '1',
        defaultThemeVersion: '124226'
      });
      return wb.ele('bookViews').ele('workbookView', {
        xWindow: '0',
        yWindow: '90',
        windowWidth: '19200',
        windowHeight: '11640'
      });
    };

    return Anchor;

  })();

  Sheet = (function() {
    function Sheet(book, name1, cols1, rows1) {
      var i, j, p, q, ref, ref1;
      this.book = book;
      this.name = name1;
      this.cols = cols1;
      this.rows = rows1;
      this.name = this.name.replace(/[\/*:?\[\]]/g, '-');
      this.data = {};
      for (i = p = 1, ref = this.rows; 1 <= ref ? p <= ref : p >= ref; i = 1 <= ref ? ++p : --p) {
        this.data[i] = {};
        for (j = q = 1, ref1 = this.cols; 1 <= ref1 ? q <= ref1 : q >= ref1; j = 1 <= ref1 ? ++q : --q) {
          this.data[i][j] = {
            v: 0
          };
        }
      }
      this.merges = [];
      this.col_wd = [];
      this.row_ht = {};
      this.styles = {};
      this.formulas = [];
      this._pageMargins = {
        left: '0.7',
        right: '0.7',
        top: '0.75',
        bottom: '0.75',
        header: '0.3',
        footer: '0.3'
      };
      this.images = [];
    }

    Sheet.prototype.addImage = function(image) {
      var decoded, id, imageToAdd, media;
      if (!image || !image.range || !image.base64 || !image.extension) {
        throw Error('please verify your image format');
      }
      if ((typeof image.range !== 'string') || !/\w+\d+:\w+\d/i.test(image.range)) {
        throw Error('Please provide range parameter like `B2:F6`.');
      }
      decoded = colCache.decode(image.range);
      this.range = {
        from: new Anchor(this.worksheet, decoded.tl, -1),
        to: new Anchor(this.worksheet, decoded.br, 0),
        editAs: 'oneCell'
      };
      id = this.book.medias.length + 1;
      imageToAdd = new Image(id, image.extension, image.base64, this.range, image.options || {});
      media = this.book._addMediaFromImage(imageToAdd);
      this.images.push(imageToAdd);
      return id;
    };

    Sheet.prototype.getImage = function(id) {
      return this.images[id];
    };

    Sheet.prototype.getImages = function() {
      return this.images;
    };

    Sheet.prototype.removeImage = function(id) {
      var foundIndex, image, index, len, p, ref;
      foundIndex = -1;
      ref = this.images;
      for (index = p = 0, len = ref.length; p < len; index = ++p) {
        image = ref[index];
        if (image.id === id) {
          foundIndex = index;
          break;
        }
      }
      if (foundIndex > -1) {
        return this.images.splice(foundIndex, 1);
      }
    };


    /* old approach for adding background images.
      addBackgroundImage: (imageId) ->
        model = {
          type: 'background',
          imageId,
        }
        @_media.push(new Image(this, model))
    
      getBackgroundImageId: ()->
        image = @_media.find(m => m.type == 'background')
        return image && image.imageId
     */

    Sheet.prototype.set = function(col, row, str) {
      var c, cell, cells, key, r;
      if (arguments.length === 1 && col && typeof col === 'object') {
        cells = col;
        for (r in cells) {
          row = cells[r];
          for (c in row) {
            cell = row[c];
            if (cell !== null && cell !== void 0) {
              this.set(+c + 1, +r + 1, cell);
            }
          }
        }
        return this;
      } else {
        if (!this.data[row] || !this.data[col]) {
          return this;
        }
        if (str instanceof Date) {
          this.set(col, row, JSDateToExcel(str));
          this.fill(col, row, {
            type: "solid",
            fgColor: "FFFFFF"
          });
          this.numberFormat(col, row, 'd-mmm');
        } else if (typeof str === 'object' && !Array.isArray(str)) {
          for (key in str) {
            if (typeof this[key] === 'function') {
              this[key](col, row, str[key]);
            } else {
              console.error('Ignoring ', key, col, row, str[key]);
            }
          }
        } else if (typeof str === 'string') {
          if (str !== null && str !== '') {
            this.data[row][col].v = this.book.ss.str2id('' + str);
          }
          return this.data[row][col].dataType = 'string';
        } else if (typeof str === 'number') {
          this.data[row][col].v = str;
          return this.data[row][col].dataType = 'number';
        } else {
          this.data[row][col].v = str;
        }
      }
      return this;
    };

    Sheet.prototype.formula = function(col, row, str) {
      var i, len, p, ref, sheet, sheet_idx;
      if (typeof str === 'string') {
        this.formulas = this.formulas || [];
        this.formulas[row] = this.formulas[row] || [];
        ref = this.book.sheets;
        for (i = p = 0, len = ref.length; p < len; i = ++p) {
          sheet = ref[i];
          if (sheet.name === this.name) {
            sheet_idx = i;
          }
        }
        this.book.cc.add_ref(sheet_idx, col, row);
        return this.formulas[row][col] = str;
      }
    };

    Sheet.prototype.note = function(col, row, note) {
      if (note && ((typeof note === 'string') || ((typeof note === 'object') && (note.length || note.text)))) {
        this.notes = this.notes || {};
        this.notes[col] = this.notes[col] || {};
        return this.notes[col][row] = note;
      }
    };

    Sheet.prototype.merge = function(from_cell, to_cell) {
      return this.merges.push({
        from: from_cell,
        to: to_cell
      });
    };

    Sheet.prototype.width = function(col, wd) {
      return this.col_wd.push({
        c: col,
        cw: wd
      });
    };

    Sheet.prototype.getColWidth = function(col) {
      var _col, len, p, ref;
      ref = this.col_wd;
      for (p = 0, len = ref.length; p < len; p++) {
        _col = ref[p];
        if (_col.c === col) {
          return Math.floor(_col.cw * 10000);
        }
      }
      return 640000;
    };

    Sheet.prototype.height = function(row, ht) {
      return this.row_ht[row] = ht;
    };

    Sheet.prototype.font = function(col, row, font_s) {
      return this.styles['font_' + col + '_' + row] = this.book.st.font2id(font_s);
    };

    Sheet.prototype.fill = function(col, row, fill_s) {
      return this.styles['fill_' + col + '_' + row] = this.book.st.fill2id(fill_s);
    };

    Sheet.prototype.border = function(col, row, bder_s) {
      return this.styles['bder_' + col + '_' + row] = this.book.st.bder2id(bder_s);
    };

    Sheet.prototype.numberFormat = function(col, row, numfmt_s) {
      return this.styles['numfmt_' + col + '_' + row] = this.book.st.numfmt2id(numfmt_s);
    };

    Sheet.prototype.align = function(col, row, align_s) {
      return this.styles['algn_' + col + '_' + row] = align_s;
    };

    Sheet.prototype.valign = function(col, row, valign_s) {
      return this.styles['valgn_' + col + '_' + row] = valign_s;
    };

    Sheet.prototype.rotate = function(col, row, textRotation) {
      return this.styles['rotate_' + col + '_' + row] = textRotation;
    };

    Sheet.prototype.wrap = function(col, row, wrap_s) {
      return this.styles['wrap_' + col + '_' + row] = wrap_s;
    };

    Sheet.prototype.autoFilter = function(filter_s) {
      return this.autofilter = typeof filter_s === 'string' ? filter_s : this.getRange();
    };

    Sheet.prototype._sheetViews = {
      workbookViewId: '0'
    };

    Sheet.prototype._sheetViewsPane = {};

    Sheet.prototype._pageSetup = {
      paperSize: '9',
      orientation: 'portrait',
      horizontalDpi: '200',
      verticalDpi: '200'
    };

    Sheet.prototype.sheetViews = function(obj) {
      var key, results, val;
      results = [];
      for (key in obj) {
        val = obj[key];
        if (typeof this[key] === 'function') {
          results.push(this[key](obj[key]));
        } else {
          results.push(this._sheetViews[key] = val);
        }
      }
      return results;
    };

    Sheet.prototype.split = function(ncols, nrows, state, activePane, topLeftCell) {
      state = state || "frozen";
      activePane = activePane || "bottomRight";
      topLeftCell = topLeftCell || (tool.i2a((ncols || 0) + 1) + ((nrows || 0) + 1));
      if (ncols) {
        this._sheetViewsPane.xSplit = '' + ncols;
      }
      if (nrows) {
        this._sheetViewsPane.ySplit = '' + nrows;
      }
      if (state) {
        this._sheetViewsPane.state = state;
      }
      if (activePane) {
        this._sheetViewsPane.activePane = activePane;
      }
      if (topLeftCell) {
        return this._sheetViewsPane.topLeftCell = topLeftCell;
      }
    };

    Sheet.prototype.printBreakRows = function(arr) {
      return this._rowBreaks = arr;
    };

    Sheet.prototype.printBreakColumns = function(arr) {
      return this._colBreaks = arr;
    };

    Sheet.prototype.printRepeatRows = function(start, end) {
      if (Array.isArray(start)) {
        return this._repeatRows = {
          start: start[0],
          end: start[1]
        };
      } else {
        return this._repeatRows = {
          start: start,
          end: end
        };
      }
    };

    Sheet.prototype.printRepeatColumns = function(start, end) {
      if (Array.isArray(start)) {
        return this._repeatCols = {
          start: start[0],
          end: start[1]
        };
      } else {
        return this._repeatCols = {
          start: start,
          end: end
        };
      }
    };

    Sheet.prototype.pageSetup = function(obj) {
      var key, results, val;
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(this._pageSetup[key] = val);
      }
      return results;
    };

    Sheet.prototype.pageMargins = function(obj) {
      var key, results, val;
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(this._pageMargins[key] = val);
      }
      return results;
    };

    Sheet.prototype.style_id = function(col, row) {
      var id, inx, style;
      inx = '_' + col + '_' + row;
      style = {
        numfmt_id: this.styles['numfmt' + inx],
        font_id: this.styles['font' + inx],
        fill_id: this.styles['fill' + inx],
        bder_id: this.styles['bder' + inx],
        align: this.styles['algn' + inx],
        valign: this.styles['valgn' + inx],
        rotate: this.styles['rotate' + inx],
        wrap: this.styles['wrap' + inx]
      };
      id = this.book.st.style2id(style);
      return id;
    };

    Sheet.prototype.getRange = function() {
      return '$A$1:$' + tool.i2a(this.cols) + '$' + this.rows;
    };

    Sheet.prototype.toxml = function() {
      var c, cb, cols, cw, ht, i, ix, j, len, len1, len2, len3, len4, m, mc, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, sd, sid, t, u, w, ws, wsRel, x, y;
      ws = xml.create('worksheet', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      ws.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      ws.att('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
      ws.ele('dimension', {
        ref: 'A1'
      });
      ws.ele('sheetViews').ele('sheetView', this._sheetViews).ele('pane', this._sheetViewsPane);
      ws.ele('sheetFormatPr', {
        defaultRowHeight: '13.5'
      });
      if (this.col_wd.length > 0) {
        cols = ws.ele('cols');
        ref = this.col_wd;
        for (p = 0, len = ref.length; p < len; p++) {
          cw = ref[p];
          cols.ele('col', {
            min: '' + cw.c,
            max: '' + cw.c,
            width: cw.cw,
            customWidth: '1'
          });
        }
      }
      sd = ws.ele('sheetData');
      for (i = q = 1, ref1 = this.rows; 1 <= ref1 ? q <= ref1 : q >= ref1; i = 1 <= ref1 ? ++q : --q) {
        r = sd.ele('row', {
          r: '' + i,
          spans: '1:' + this.cols
        });
        ht = this.row_ht[i];
        if (ht) {
          r.att('ht', ht);
          r.att('customHeight', '1');
        }
        for (j = t = 1, ref2 = this.cols; 1 <= ref2 ? t <= ref2 : t >= ref2; j = 1 <= ref2 ? ++t : --t) {
          ix = this.data[i][j];
          sid = this.style_id(j, i);
          if ((ix.v !== null && ix.v !== void 0) || (sid !== 1)) {
            c = r.ele('c', {
              r: '' + tool.i2a(j) + i
            });
            if (sid !== 1) {
              c.att('s', '' + (sid - 1));
            }
            if (this.formulas[i] && this.formulas[i][j]) {
              c.ele('f', '' + this.formulas[i][j]);
              c.ele('v');
            } else if (ix.dataType === 'string') {
              c.att('t', 's');
              c.ele('v', '' + (ix.v - 1));
            } else if (ix.dataType === 'number') {
              c.ele('v', '' + ix.v);
            }
          }
        }
      }
      if (this.merges.length > 0) {
        mc = ws.ele('mergeCells', {
          count: this.merges.length
        });
        ref3 = this.merges;
        for (u = 0, len1 = ref3.length; u < len1; u++) {
          m = ref3[u];
          mc.ele('mergeCell', {
            ref: '' + tool.i2a(m.from.col) + m.from.row + ':' + tool.i2a(m.to.col) + m.to.row
          });
        }
      }
      if (typeof this.autofilter === 'string') {
        ws.ele('autoFilter', {
          ref: this.autofilter
        });
      }
      ws.ele('phoneticPr', {
        fontId: '1',
        type: 'noConversion'
      });
      ws.ele('pageMargins', this._pageMargins);
      ws.ele('pageSetup', this._pageSetup);
      if (this._rowBreaks && this._rowBreaks.length) {
        cb = ws.ele('rowBreaks', {
          count: this._rowBreaks.length,
          manualBreakCount: this._rowBreaks.length
        });
        ref4 = this._rowBreaks;
        for (w = 0, len2 = ref4.length; w < len2; w++) {
          i = ref4[w];
          cb.ele('brk', {
            id: i,
            man: '1',
            max: "1048575"
          });
        }
      }
      if (this._colBreaks && this._colBreaks.length) {
        cb = ws.ele('colBreaks', {
          count: this._colBreaks.length,
          manualBreakCount: this._colBreaks.length
        });
        ref5 = this._colBreaks;
        for (x = 0, len3 = ref5.length; x < len3; x++) {
          i = ref5[x];
          cb.ele('brk', {
            id: i,
            man: '1',
            max: "1048575"
          });
        }
      }
      ref6 = this.wsRels;
      for (y = 0, len4 = ref6.length; y < len4; y++) {
        wsRel = ref6[y];
        if (wsRel.type === 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing') {
          ws.ele('legacyDrawing', {
            'r:id': wsRel.id
          });
        }
      }
      return ws.end({
        pretty: false
      });
    };

    return Sheet;

  })();

  CalcChain = (function() {
    function CalcChain(book) {
      this.book = book;
      this.cache = {};
    }

    CalcChain.prototype.add_ref = function(idx, col, row) {
      var num;
      num = idx + 1;
      if (!this.cache.hasOwnProperty(num)) {
        this.cache[num] = [];
      }
      return this.cache[num].push(tool.i2a(col) + row);
    };

    CalcChain.prototype.toxml = function() {
      var cc, el, key, len, p, ref, val;
      cc = xml.create('calcChain', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      cc.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      ref = this.cache;
      for (key in ref) {
        val = ref[key];
        for (p = 0, len = val.length; p < len; p++) {
          el = val[p];
          cc.ele('c', {
            r: '' + el,
            i: '' + key
          });
        }
      }
      return cc.end({
        pretty: false
      });
    };

    return CalcChain;

  })();

  CalcChain = (function() {
    function CalcChain(book) {
      this.book = book;
      this.cache = {};
    }

    CalcChain.prototype.add_ref = function(idx, col, row) {
      var num;
      num = idx + 1;
      if (!this.cache.hasOwnProperty(num)) {
        this.cache[num] = [];
      }
      return this.cache[num].push(tool.i2a(col) + row);
    };

    CalcChain.prototype.toxml = function() {
      var cc, el, key, len, p, ref, val;
      cc = xml.create('calcChain', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      cc.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      ref = this.cache;
      for (key in ref) {
        val = ref[key];
        for (p = 0, len = val.length; p < len; p++) {
          el = val[p];
          cc.ele('c', {
            r: '' + el,
            i: '' + key
          });
        }
      }
      return cc.end();
    };

    return CalcChain;

  })();

  Style = (function() {
    Style.prototype.numberFormats = {
      0: 'General',
      1: '0',
      2: '0.00',
      3: '#,##0',
      4: '#,##0.00',
      9: '0%',
      10: '0.00%',
      11: '0.00E+00',
      12: '# ?/?',
      13: '# ??/??',
      14: 'm/d/yy',
      15: 'd-mmm-yy',
      16: 'd-mmm',
      17: 'mmm-yy',
      18: 'h:mm AM/PM',
      19: 'h:mm:ss AM/PM',
      20: 'h:mm',
      21: 'h:mm:ss',
      22: 'm/d/yy h:mm',
      37: '#,##0 ;(#,##0)',
      38: '#,##0 ;[Red](#,##0)',
      39: '#,##0.00;(#,##0.00)',
      40: '#,##0.00;[Red](#,##0.00)',
      45: 'mm:ss',
      46: '[h]:mm:ss',
      47: 'mmss.0',
      48: '##0.0E+0',
      49: '@',
      56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
    };

    function Style(book) {
      this.book = book;
      this.cache = {};
      this.mfonts = [];
      this.mfills = [];
      this.mbders = [];
      this.mstyle = [];
      this.numFmtNextId = 164;
      this.with_default();
    }

    Style.prototype.with_default = function() {
      this.def_font_id = this.font2id(null);
      this.def_fill_id = this.fill2id(null);
      this.def_bder_id = this.bder2id(null);
      this.def_align = '-';
      this.def_valign = '-';
      this.def_rotate = '-';
      this.def_wrap = '-';
      this.def_numfmt_id = 0;
      return this.def_style_id = this.style2id({
        font_id: this.def_font_id,
        fill_id: this.def_fill_id,
        bder_id: this.def_bder_id,
        align: this.def_align,
        valign: this.def_valign,
        rotate: this.def_rotate
      });
    };

    Style.prototype.font2id = function(font) {
      var id, k;
      font || (font = {});
      font.bold || (font.bold = '-');
      font.iter || (font.iter = '-');
      font.sz || (font.sz = '11');
      font.color || (font.color = '-');
      font.name || (font.name = 'Calibri');
      font.scheme || (font.scheme = 'minor');
      font.family || (font.family = '2');
      font.underline || (font.underline = '-');
      font.strike || (font.strike = '-');
      font.outline || (font.outline = '-');
      font.shadow || (font.shadow = '-');
      k = 'font_' + font.bold + font.iter + font.sz + font.color + font.name + font.scheme + font.family + font.underline + font.strike + font.outline + font.shadow;
      id = this.cache[k];
      if (id) {
        return id;
      } else {
        this.mfonts.push(font);
        this.cache[k] = this.mfonts.length;
        return this.mfonts.length;
      }
    };

    Style.prototype.fill2id = function(fill) {
      var id, k;
      fill || (fill = {});
      fill.type || (fill.type = 'none');
      fill.bgColor || (fill.bgColor = '-');
      fill.fgColor || (fill.fgColor = '-');
      k = 'fill_' + fill.type + fill.bgColor + fill.fgColor;
      id = this.cache[k];
      if (id) {
        return id;
      } else {
        this.mfills.push(fill);
        this.cache[k] = this.mfills.length;
        return this.mfills.length;
      }
    };

    Style.prototype.bder2id = function(bder) {
      var id, k;
      bder || (bder = {});
      bder.left || (bder.left = '-');
      bder.right || (bder.right = '-');
      bder.top || (bder.top = '-');
      bder.bottom || (bder.bottom = '-');
      k = JSON.stringify(["bder_", bder.left, bder.right, bder.top, bder.bottom]);
      id = this.cache[k];
      if (id) {
        return id;
      } else {
        this.mbders.push(bder);
        this.cache[k] = this.mbders.length;
        return this.mbders.length;
      }
    };

    Style.prototype.numfmt2id = function(numfmt) {
      var key;
      if (typeof numfmt === 'number') {
        return numfmt;
      } else if (typeof numfmt === 'string') {
        for (key in this.numberFormats) {
          if (this.numberFormats[key] === numfmt) {
            return parseInt(key);
          }
        }
        if (!numfmt) {
          throw "Invalid format specification";
        }
        this.numberFormats[++this.numFmtNextId] = numfmt;
        return this.numFmtNextId;
      }
    };

    Style.prototype.style2id = function(style) {
      var id, k;
      style.align || (style.align = this.def_align);
      style.valign || (style.valign = this.def_valign);
      style.rotate || (style.rotate = this.def_rotate);
      style.wrap || (style.wrap = this.def_wrap);
      style.font_id || (style.font_id = this.def_font_id);
      style.fill_id || (style.fill_id = this.def_fill_id);
      style.bder_id || (style.bder_id = this.def_bder_id);
      style.numfmt_id || (style.numfmt_id = this.def_numfmt_id);
      k = 's_' + [style.font_id, style.fill_id, style.bder_id, style.align, style.valign, style.wrap, style.rotate, style.numfmt_id].join('_');
      id = this.cache[k];
      if (id) {
        return id;
      } else {
        this.mstyle.push(style);
        this.cache[k] = this.mstyle.length;
        return this.mstyle.length;
      }
    };

    Style.prototype.toxml = function() {
      var bders, cs, customNumFmts, e, ea, es, fills, fmt, fonts, key, len, len1, len2, len3, len4, numFmts, o, p, q, ref, ref1, ref2, ref3, ref4, ss, t, u, w;
      ss = xml.create('styleSheet', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      ss.att('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
      customNumFmts = [];
      ref = this.numberFormats;
      for (key in ref) {
        fmt = ref[key];
        if (parseInt(key) >= 164) {
          customNumFmts.push({
            numFmtId: key,
            formatCode: fmt
          });
        }
      }
      if (customNumFmts.length > 0) {
        numFmts = ss.ele('numFmts', {
          count: customNumFmts.length
        });
        for (p = 0, len = customNumFmts.length; p < len; p++) {
          o = customNumFmts[p];
          numFmts.ele('numFmt', o);
        }
      }
      fonts = ss.ele('fonts', {
        count: this.mfonts.length
      });
      ref1 = this.mfonts;
      for (q = 0, len1 = ref1.length; q < len1; q++) {
        o = ref1[q];
        e = fonts.ele('font');
        if (o.bold !== '-') {
          e.ele('b');
        }
        if (o.iter !== '-') {
          e.ele('i');
        }
        if (o.underline !== '-') {
          e.ele('u');
        }
        if (o.strike !== '-') {
          e.ele('strike');
        }
        if (o.outline !== '-') {
          e.ele('outline');
        }
        if (o.shadow !== '-') {
          e.ele('shadow');
        }
        e.ele('sz', {
          val: o.sz
        });
        if (o.color !== '-') {
          e.ele('color', {
            rgb: o.color
          });
        }
        e.ele('name', {
          val: o.name
        });
        e.ele('family', {
          val: o.family
        });
        e.ele('charset', {
          val: '134'
        });
        if (o.scheme !== '-') {
          e.ele('scheme', {
            val: 'minor'
          });
        }
      }
      fills = ss.ele('fills', {
        count: this.mfills.length + 2
      });
      fills.ele('fill').ele('patternFill', {
        patternType: 'none'
      });
      fills.ele('fill').ele('patternFill', {
        patternType: 'gray125'
      });
      ref2 = this.mfills;
      for (t = 0, len2 = ref2.length; t < len2; t++) {
        o = ref2[t];
        e = fills.ele('fill');
        es = e.ele('patternFill', {
          patternType: o.type
        });
        if (o.fgColor !== '-') {
          es.ele('fgColor', {
            rgb: o.fgColor
          });
        }
        if (o.bgColor !== '-') {
          es.ele('bgColor', {
            indexed: o.bgColor
          });
        }
      }
      bders = ss.ele('borders', {
        count: this.mbders.length
      });
      ref3 = this.mbders;
      for (u = 0, len3 = ref3.length; u < len3; u++) {
        o = ref3[u];
        e = bders.ele('border');
        if (o.left !== '-') {
          if (typeof o.left === 'string') {
            e.ele('left', {
              style: o.left
            }).ele('color', {
              auto: '1'
            });
          } else {
            e.ele('left', {
              style: o.left.style
            }).ele('color', o.left.color);
          }
        } else {
          e.ele('left');
        }
        if (o.right !== '-') {
          if (typeof o.right === 'string') {
            e.ele('right', {
              style: o.right
            }).ele('color', {
              auto: '1'
            });
          } else {
            e.ele('right', {
              style: o.right.style
            }).ele('color', o.right.color);
          }
        } else {
          e.ele('right');
        }
        if (o.top !== '-') {
          if (typeof o.top === 'string') {
            e.ele('top', {
              style: o.top
            }).ele('color', {
              auto: '1'
            });
          } else {
            e.ele('top', {
              style: o.top.style
            }).ele('color', o.top.color);
          }
        } else {
          e.ele('top');
        }
        if (o.bottom !== '-') {
          if (typeof o.bottom === 'string') {
            e.ele('bottom', {
              style: o.bottom
            }).ele('color', {
              auto: '1'
            });
          } else {
            e.ele('bottom', {
              style: o.bottom.style
            }).ele('color', o.bottom.color);
          }
        } else {
          e.ele('bottom');
        }
        e.ele('diagonal');
      }
      ss.ele('cellStyleXfs', {
        count: '1'
      }).ele('xf', {
        numFmtId: '0',
        fontId: '0',
        fillId: '0',
        borderId: '0'
      }).ele('alignment', {
        vertical: 'center'
      });
      cs = ss.ele('cellXfs', {
        count: this.mstyle.length
      });
      ref4 = this.mstyle;
      for (w = 0, len4 = ref4.length; w < len4; w++) {
        o = ref4[w];
        e = cs.ele('xf', {
          numFmtId: o.numfmt_id || '0',
          fontId: o.font_id - 1,
          fillId: o.fill_id + 1,
          borderId: o.bder_id - 1,
          xfId: '0'
        });
        if (o.font_id !== 1) {
          e.att('applyFont', '1');
        }
        if (o.fill_id !== 1) {
          e.att('applyFill', '1');
        }
        if (o.numfmt_id !== void 0) {
          e.att('applyNumberFormat', '1');
        }
        if (o.bder_id !== 1) {
          e.att('applyBorder', '1');
        }
        if (o.align !== '-' || o.valign !== '-' || o.wrap !== '-') {
          e.att('applyAlignment', '1');
          ea = e.ele('alignment', {
            textRotation: (o.rotate === '-' ? '0' : o.rotate),
            horizontal: (o.align === '-' ? 'left' : o.align),
            vertical: (o.valign === '-' ? 'bottom' : o.valign)
          });
          if (o.wrap !== '-') {
            ea.att('wrapText', '1');
          }
        }
      }
      ss.ele('cellStyles', {
        count: '1'
      }).ele('cellStyle', {
        name: 'Normal',
        xfId: '0',
        builtinId: '0'
      });
      ss.ele('dxfs', {
        count: '0'
      });
      ss.ele('tableStyles', {
        count: '0',
        defaultTableStyle: 'TableStyleMedium9',
        defaultPivotStyle: 'PivotStyleLight16'
      });
      return ss.end({
        pretty: false
      });
    };

    return Style;

  })();

  Image = (function() {
    function Image(id1, extension, content, range1, options) {
      this.id = id1;
      this.extension = extension;
      this.content = content;
      this.range = range1;
      this.options = options;
      this.editAs = 'oneCell';
    }

    Image.prototype.publish = function(sheet, zip, media) {};

    Image.prototype.toDrawingXml = function(relId, spec) {
      var _from, _to, blip, blipFill, blipModel, cNvPr, dr, ext, extLst, graphic_index, nvPicPr, pic, spPr, twoCellAnchor, xfrm;
      dr = xml.create('xdr:wsDr', {
        version: '1.0',
        encoding: 'UTF-8',
        standalone: true
      });
      dr.att('xmlns:xdr', 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing');
      dr.att('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
      twoCellAnchor = dr.ele('xdr:twoCellAnchor', {
        editAs: this.editAs
      });
      _from = twoCellAnchor.ele('xdr:from');
      _from.ele('xdr:col', this.range.from.model.nativeCol);
      _from.ele('xdr:colOff', this.range.from.model.nativeColOff);
      _from.ele('xdr:row', this.range.from.model.nativeRow);
      _from.ele('xdr:rowOff', this.range.from.model.nativeRowOff);
      _to = twoCellAnchor.ele('xdr:to');
      _to.ele('xdr:col', this.range.to.model.nativeCol);
      _to.ele('xdr:colOff', this.range.to.model.nativeColOff);
      _to.ele('xdr:row', this.range.to.model.nativeRow);
      _to.ele('xdr:rowOff', this.range.to.model.nativeRowOff);
      pic = twoCellAnchor.ele('xdr:pic');
      nvPicPr = pic.ele('xdr:nvPicPr');
      graphic_index = 30924 || Math.round(Math.random() * 100000);
      cNvPr = nvPicPr.ele('xdr:cNvPr', {
        id: 3,
        name: 'Graphic ' + graphic_index
      });
      cNvPr.ele('a:extLst').ele('a:ext', {
        uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}'
      }).ele('a16:creationId', {
        'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',
        'id': '{9D66B5F7-2553-484C-A5BE-4D0B8D57E08B}'
      });
      nvPicPr.ele('xdr:cNvPicPr').ele('a:picLocks', {
        noChangeAspect: 1
      });
      blipFill = pic.ele('xdr:blipFill');
      blipModel = {
        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
      };
      if (relId) {
        blipModel["r:embed"] = relId;
      }
      blipModel['cstate'] = "print";
      blip = blipFill.ele('a:blip', blipModel);
      extLst = blip.ele('a:extLst');
      ext = extLst.ele('a:ext', {
        'uri': '{28A0092B-C50C-407E-A947-70E740481C1C}'
      });
      ext.ele('a14:useLocalDpi', {
        'xmlns:a14': 'http://schemas.microsoft.com/office/drawing/2010/main',
        'val': 0
      });
      if (this.extension === 'svg') {
        ext = extLst.ele('a:ext', {
          'uri': '{96DAC541-7B7A-43D3-8B79-37D633B846F1}'
        });
        ext.ele('asvg:svgBlip', {
          'xmlns:asvg': 'http://schemas.microsoft.com/office/drawing/2016/SVG/main',
          'r:embed': relId
        });
      }
      if (this.options.stretch) {
        blipFill.ele('a:stretch');
      }
      blipFill.ele('srcRect');
      spPr = pic.ele('xdr:spPr');
      xfrm = spPr.ele('a:xfrm');
      xfrm.ele('a:off', {
        'x': 609600,
        'y': 190500
      });
      xfrm.ele('a:ext', {
        'cx': 2857500,
        'cy': 2857500
      });
      spPr.ele('a:prstGeom', {
        'prst': 'rect'
      }).ele('a:avLst');
      twoCellAnchor.ele('xdr:clientData');
      return dr.end({
        pretty: false
      });
    };

    return Image;

  })();

  Workbook = (function() {
    function Workbook(fpath1, fname1) {
      var args;
      this.fpath = fpath1;
      this.fname = fname1;
      this.generate = bind(this.generate, this);
      if (typeof this.fpath === 'object') {
        args = this.fpath;
        this.fname = args.name;
        this.fpath = args.path;
      }
      this.id = '' + parseInt(Math.random() * 9999999);
      this.sheets = [];
      this.medias = [];
      this.ss = new SharedStrings;
      this.ct = new ContentTypes(this);
      this.da = new DocPropsApp(this);
      this.wb = new XlWorkbook(this);
      this.wbre = new XlWorkbookRels(this);
      this.st = new Style(this);
      this.cc = new CalcChain(this);
      this.cc = new CalcChain(this);
    }

    Workbook.prototype.set = function(obj) {
      var key, val;
      if (obj && typeof obj === 'object') {
        for (key in obj) {
          val = obj[key];
          if (typeof this[key] === 'function') {
            this[key](val);
          }
        }
      }
      return this;
    };

    Workbook.prototype.createSheet = function(name, cols, rows) {
      var args, sheet;
      if (name && typeof name === 'object') {
        args = name;
        return this.createSheet(args.name, args.cols, args.rows).set(args.set);
      }
      sheet = new Sheet(this, name, cols, rows);
      this.sheets.push(sheet);
      return sheet;
    };

    Workbook.prototype._addMediaFromImage = function(image) {
      return this.medias.push({
        image: image
      });
    };

    Workbook.prototype._removeMediaFromImage = function(image) {
      var foundIndex, i, len, media, p, ref;
      foundIndex = -1;
      ref = this.medias;
      for (i = p = 0, len = ref.length; p < len; i = ++p) {
        media = ref[i];
        if (media.image.id = image.id) {
          foundIndex = i;
          break;
        }
      }
      if (!(foundIndex > -1)) {
        return this.medias.splice(foundIndex, 1);
      }
    };

    Workbook.prototype.save = function(target, opts, cb) {
      if (arguments.length === 1 && typeof target === 'function') {
        cb = target;
        target = this.fpath + '/' + this.fname;
        opts = {};
      } else if (arguments.length === 2 && typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      return this.generate(function(err, zip) {
        var args, buffer;
        buffer = void 0;
        args = {
          type: 'nodebuffer'
        };
        if (opts.compressed) {
          args.compressed = "DEFLATE";
        }
        return buffer = zip.generateAsync(args).then(function(buffer) {
          if (err) {
            return cb(err);
          }
          return fs.writeFile(target, buffer, cb);
        });
      });
    };

    Workbook.prototype.generate = function(cb) {
      var drawingFilename, dwRels, i, image, j, key, len, len1, mediaFilename, p, q, ref, ref1, relId, self, sheet, wbMediaCounter, zip;
      self = this;
      if (!cb) {
        return new Promise(function(resolve, reject) {
          return self.generate(function(err, zip) {
            if (err) {
              return reject(err);
            }
            return resolve(zip);
          });
        });
      }
      zip = new JSZip();
      for (key in baseXl) {
        zip.file(key, baseXl[key]);
      }
      zip.file('[Content_Types].xml', this.ct.toxml());
      zip.file('docProps/app.xml', this.da.toxml());
      zip.file('xl/workbook.xml', this.wb.toxml());
      zip.file('xl/sharedStrings.xml', this.ss.toxml());
      zip.file('xl/_rels/workbook.xml.rels', this.wbre.toxml());
      wbMediaCounter = 1;
      ref = this.sheets;
      for (i = p = 0, len = ref.length; p < len; i = ++p) {
        sheet = ref[i];
        sheet.wsRels = [];
        sheet.wsComments = {};
        if (sheet.notes) {
          relId = 'rId' + (sheet.wsRels.length + 1);
          drawingFilename = '../drawings/vmlDrawing' + (i + 1) + '.vml';
          sheet.wsRels.push({
            id: relId,
            target: drawingFilename,
            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing'
          });
          relId = 'rId' + (sheet.wsRels.length + 1);
          sheet.wsRels.push({
            id: relId,
            target: '../comments' + (i + 1) + '.xml',
            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments'
          });
          zip.file('xl/drawings/vmlDrawing' + (i + 1) + '.vml', new WorksheetCommentsDrawings(sheet.notes).toxml());
        }
        ref1 = sheet.images;
        for (j = q = 0, len1 = ref1.length; q < len1; j = ++q) {
          image = ref1[j];
          dwRels = [];
          relId = 'rId' + (sheet.wsRels.length + 1);
          mediaFilename = [wbMediaCounter, '.', image.extension].join('');
          zip.file('xl/media/image' + mediaFilename, image.content, {
            base64: true
          });
          dwRels.push({
            id: relId,
            target: '../media/image' + mediaFilename
          });
          drawingFilename = wbMediaCounter + '.xml';
          sheet.wsRels.push({
            id: relId,
            target: '../drawings/drawing' + drawingFilename,
            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing'
          });
          zip.file('xl/drawings/drawing' + drawingFilename, image.toDrawingXml(relId, image));
          zip.file('xl/drawings/_rels/drawing' + wbMediaCounter + '.xml.rels', new XlDrawingRels(dwRels).toxml());
          wbMediaCounter++;
        }
        zip.file('xl/worksheets/_rels/sheet' + (i + 1) + '.xml.rels', new XlWorksheetRels(sheet.wsRels).toxml());
        if (sheet.notes) {
          zip.file('xl/comments' + (i + 1) + '.xml', new WorksheetComments(sheet.notes).toxml());
        }
        zip.file('xl/worksheets/sheet' + (i + 1) + '.xml', this.sheets[i].toxml());
      }
      zip.file('xl/styles.xml', this.st.toxml());
      if (Object.getOwnPropertyNames(this.cc.cache).length > 0) {
        zip.file('xl/calcChain.xml', this.cc.toxml());
      }
      return cb(null, zip);
    };

    Workbook.prototype.cancel = function() {
      return console.error("workbook.cancel() is deprecated");
    };

    return Workbook;

  })();

  excelbuilder = {
    createWorkbook: function(fpath, fname) {
      return new Workbook(fpath, fname);
    },
    set: function(obj) {
      var key, val;
      if (obj && (typeof obj === 'object')) {
        for (val in obj) {
          key = obj[val];
          if (typeof this[key] === 'function') {
            this[key](val);
          }
        }
      }
      return this;
    }
  };

  JSDateToExcel = function(dt) {
    return dt.valueOf() / 86400000 + 25569;
  };

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports = excelbuilder;
  }

  if ((typeof window !== "undefined" && window !== null)) {
    window.excelbuilder = excelbuilder;
  }

  baseXl = {
    '_rels/.rels': '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>',
    'docProps/core.xml': '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>Administrator</dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2006-09-13T11:21:51Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2006-09-13T11:21:55Z</dcterms:modified></cp:coreProperties>',
    'xl/theme/theme1.xml': '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office 主题"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="1F497D"/></a:dk2><a:lt2><a:srgbClr val="EEECE1"/></a:lt2><a:accent1><a:srgbClr val="4F81BD"/></a:accent1><a:accent2><a:srgbClr val="C0504D"/></a:accent2><a:accent3><a:srgbClr val="9BBB59"/></a:accent3><a:accent4><a:srgbClr val="8064A2"/></a:accent4><a:accent5><a:srgbClr val="4BACC6"/></a:accent5><a:accent6><a:srgbClr val="F79646"/></a:accent6><a:hlink><a:srgbClr val="0000FF"/></a:hlink><a:folHlink><a:srgbClr val="800080"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Cambria"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="宋体"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:majorFont><a:minorFont><a:latin typeface="Calibri"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="宋体"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/></a:theme>',
    'xl/styles.xml': '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><fonts count="2"><font><sz val="11"/><color theme="1"/><name val="宋体"/><family val="2"/><charset val="134"/><scheme val="minor"/></font><font><sz val="9"/><name val="宋体"/><family val="2"/><charset val="134"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"><alignment vertical="center"/></xf></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"><alignment vertical="center"/></xf></cellXfs><cellStyles count="1"><cellStyle name="常规" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleLight16"/></styleSheet>'
  };

}).call(this);

//# sourceMappingURL=msexcel-builder.js.map
